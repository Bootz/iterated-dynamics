<html>
<head>
<title>Iterated Dynamics: Page 67</title>
</head>
<body>
<div>
<pre>
<a href="page66.html">&lt; Prev</a>           Iterated Dynamics Version 1.0          Page 67 <a href="page68.html">Next &gt;</a></pre>
</div>
<pre>
                       == (equal to), != (not equal to)
            7          &amp;&amp; (logical AND), || (logical OR)
  Precedence may be overridden by use of parenthesis.  Note the modulus
  squared operator |z| is also parenthetic and always sets the imaginary
  component to zero.  This means 'c * |z - 4|' first subtracts 4 from z,
  calculates the modulus squared then multiplies times 'c'.  Nested
  modulus squared operators require overriding parenthesis:

     c * |z + (|pixel|)|

  The functions fn1(...) to fn4(...) are variable functions - when used,
  the user is prompted at run time (on the &lt;Z&gt; screen) to specify one of
  sin, cos, sinh, cosh, exp, log, sqr, etc. for each required variable
  function.

  Most of the functions have their conventional meaning, here are a few
  notes on others that are not conventional.
   abs()    - returns abs(x)+i*abs(y)
   |x+iy|   - returns x*x+y*y
   cabs()   - returns sqrt(x*x+y*y)
   conj()   - returns the complex conjugate of the argument. That is, changes
              sign of the imaginary component of argument: (x,y) becomes (x,-y)
   cosxx()  - duplicates a bug in the version 16 cos() function
   flip()   - Swap the real and imaginary components of the complex number.
              e.g. (4,5) would become (5,4)
   ident()  - identity function. Leaves the value of the argument unchanged,
              acting like a "z" term in a formula.
   zero()   - returns 0.
   one()    - returns 1.
   floor()  - largest integer not greater than the argument
              floor(x+iy) = floor(x) + i*floor(y)
   ceil()   - smallest integer not less than the argument
   trunc()  - truncate fraction part toward zero
   round()  - round to nearest integer or up. e.g. round(2.5,3.4) = (3,3)

  The formulas are performed using either integer or floating point
  mathematics depending on the &lt;F&gt; floating point toggle.  If you do not
  have an FPU then type MPC math is performed in lieu of traditional
  floating point.

  The 'rand' predefined variable is changed with each iteration to a new
  random number with the real and imaginary components containing a value
  between zero and 1. Use the srand() function to initialize the random
  numbers to a consistent random number sequence.  If a formula does not
  contain the srand() function, then the formula compiler will use the
  system time to initialize the sequence.  This could cause a different
  fractal to be generated each time the formula is used depending on how
  the formula is written.

  A formula containing one of the predefined variables "maxit", "scrnpix"
  or "scrnmax" will be automatically run in floating point mode.

  The rounding functions must be used cautiously; formulas that depend on
  exact values of numbers will not work reliably in all cases.  For
  example, in floating point mode, trunc(6/3) returns 1 while
  trunc(6/real(3)) returns 2.
</pre>
</body>
</html>
